<?xml version="1.0" encoding="UTF-8"?>

<!-- =====================================================================
DeframerComponentAi.xml
Generated by fpp-to-xml
====================================================================== -->
<component namespace="Svc" name="Deframer" kind="passive">

  <comment>
  A component for deframing input received from the ground
  via a byte stream driver, which may be active or passive
  </comment>

  <import_port_type>Drv/ByteStreamDriverModel/ByteStreamPollPortAi.xml</import_port_type>
  <import_port_type>Drv/ByteStreamDriverModel/ByteStreamRecvPortAi.xml</import_port_type>
  <import_port_type>Fw/Buffer/BufferGetPortAi.xml</import_port_type>
  <import_port_type>Fw/Buffer/BufferSendPortAi.xml</import_port_type>
  <import_port_type>Fw/Cmd/CmdResponsePortAi.xml</import_port_type>
  <import_port_type>Fw/Com/ComPortAi.xml</import_port_type>
  <import_port_type>Svc/Sched/SchedPortAi.xml</import_port_type>

  <ports>
    <port name="bufferAllocate" data_type="Fw::BufferGet" kind="output" max_number="1">
      <comment>
      Port for allocating Fw::Buffer objects from a buffer manager.
      When Deframer invokes this port, it receives a packet buffer PB and
      takes ownership of it. It uses PB internally for deframing.
      Then one of two things happens:

      1. PB contains a file packet, which Deframer sends on bufferOut.
      In this case ownership of PB passes to the receiver.

      2. PB does not contain a file packet, or bufferOut is unconnected.
      In this case Deframer deallocates PB on bufferDeallocate.
      </comment>
    </port>
    <port name="bufferDeallocate" data_type="Fw::BufferSend" kind="output" max_number="1">
      <comment>
      Port for deallocating temporary buffers allocated with
      bufferAllocate (case 2 above). Deallocation occurs here
      when there is nothing to send on bufferOut.
      </comment>
    </port>
    <port name="bufferOut" data_type="Fw::BufferSend" kind="output" max_number="1">
      <comment>
      Port for sending file packets (case 1 above).
      The file packets are wrapped in Fw::Buffer objects allocated with
      bufferAllocate.
      Ownership of the Fw::Buffer passes to the receiver, which is
      responsible for the deallocation.
      </comment>
    </port>
    <port name="cmdResponseIn" data_type="Fw::CmdResponse" kind="sync_input" max_number="1">
      <comment>
      Port for receiving command responses from a command dispatcher.
      Invoking this port does nothing. The port exists to allow the matching
      connection in the topology.
      </comment>
    </port>
    <port name="comOut" data_type="Fw::Com" kind="output" max_number="1">
      <comment>
      Port for sending command packets as Com buffers.
      </comment>
    </port>
    <port name="framedDeallocate" data_type="Fw::BufferSend" kind="output" max_number="1">
      <comment>
      Port for deallocating buffers received on framedIn.
      </comment>
    </port>
    <port name="framedIn" data_type="Drv::ByteStreamRecv" kind="guarded_input" max_number="1">
      <comment>
      Port for receiving frame buffers FB pushed from the byte stream driver.
      After using a buffer FB received on this port, Deframer deallocates it
      by invoking framedDeallocate.
      </comment>
    </port>
    <port name="framedPoll" data_type="Drv::ByteStreamPoll" kind="output" max_number="1">
      <comment>
      Port that polls for data from the byte stream driver.
      Deframer invokes this port on its schedIn cycle, if it is connected.
      No allocation or occurs when invoking this port.
      The data transfer uses a pre-allocated frame buffer
      owned by Deframer.
      </comment>
    </port>
    <port name="schedIn" data_type="Svc::Sched" kind="guarded_input" max_number="1">
      <comment>
      Schedule in port, driven by a rate group.
      </comment>
    </port>
  </ports>

</component>
