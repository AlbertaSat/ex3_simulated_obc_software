// ======================================================================
// \title  SendFileRequestPortAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for SendFileRequest port
// ======================================================================

#include "F-Prime/Svc/FileDownlinkPorts/SendFileRequestPortAc.hpp"
#include "Fw/Types/Assert.hpp"
#include "Fw/Types/StringUtils.hpp"

namespace Svc {

  namespace SendFileRequestPortStrings {

    // ----------------------------------------------------------------------
    // StringSize100 class
    // ----------------------------------------------------------------------

    StringSize100 ::
      StringSize100() :
        StringBase()
    {
      this->m_buf[0] = 0;
    }

    StringSize100 ::
      StringSize100(const char* src) :
        StringBase()
    {
      Fw::StringUtils::string_copy(this->m_buf, src, sizeof(this->m_buf));
    }

    StringSize100 ::
      StringSize100(const Fw::StringBase& src) :
        StringBase()
    {
      Fw::StringUtils::string_copy(this->m_buf, src.toChar(), sizeof(this->m_buf));
    }

    StringSize100 ::
      StringSize100(const StringSize100& src) :
        StringBase()
    {
      Fw::StringUtils::string_copy(this->m_buf, src.toChar(), sizeof(this->m_buf));
    }

    StringSize100 ::
      ~StringSize100()
    {

    }

    StringSize100& StringSize100 ::
      operator=(const StringSize100& other)
    {
      if (this == &other) {
        return *this;
      }

      Fw::StringUtils::string_copy(this->m_buf, other.toChar(), sizeof(this->m_buf));
      return *this;
    }

    StringSize100& StringSize100 ::
      operator=(const Fw::StringBase& other)
    {
      if (this == &other) {
        return *this;
      }

      Fw::StringUtils::string_copy(this->m_buf, other.toChar(), sizeof(this->m_buf));
      return *this;
    }

    StringSize100& StringSize100 ::
      operator=(const char* other)
    {
      Fw::StringUtils::string_copy(this->m_buf, other, sizeof(this->m_buf));
      return *this;
    }

    const char* StringSize100 ::
      toChar() const
    {
      return this->m_buf;
    }

    NATIVE_UINT_TYPE StringSize100 ::
      getCapacity() const
    {
      return sizeof(this->m_buf);
    }

  }

  // ----------------------------------------------------------------------
  // Input Port Member functions
  // ----------------------------------------------------------------------

  InputSendFileRequestPort ::
    InputSendFileRequestPort() :
      Fw::InputPortBase(),
      m_func(nullptr)
  {

  }

  void InputSendFileRequestPort ::
    init()
  {
    Fw::InputPortBase::init();
  }

  void InputSendFileRequestPort ::
    addCallComp(
        Fw::PassiveComponentBase* callComp,
        CompFuncPtr funcPtr
    )
  {
    FW_ASSERT(callComp != nullptr);
    FW_ASSERT(funcPtr != nullptr);

    this->m_comp = callComp;
    this->m_func = funcPtr;
    this->m_connObj = callComp;
  }

  Svc::SendFileResponse InputSendFileRequestPort ::
    invoke(
        const SendFileRequestPortStrings::StringSize100& sourceFileName,
        const SendFileRequestPortStrings::StringSize100& destFileName,
        U32 offset,
        U32 length
    )
  {
#if FW_PORT_TRACING == 1
    this->trace();
#endif

    FW_ASSERT(this->m_comp != nullptr);
    FW_ASSERT(this->m_func != nullptr);

    return this->m_func(this->m_comp, this->m_portNum, sourceFileName, destFileName, offset, length);
  }

#if FW_PORT_SERIALIZATION == 1

  Fw::SerializeStatus InputSendFileRequestPort ::
    invokeSerial(Fw::SerializeBufferBase& _buffer)
  {
    // For ports with a return type, invokeSerial is not used
    (void) _buffer;

    FW_ASSERT(0);
    return Fw::FW_SERIALIZE_OK;
  }

#endif

  // ----------------------------------------------------------------------
  // Output Port Member functions
  // ----------------------------------------------------------------------

  OutputSendFileRequestPort ::
    OutputSendFileRequestPort() :
      Fw::OutputPortBase(),
      m_port(nullptr)
  {

  }

  void OutputSendFileRequestPort ::
    init()
  {
    Fw::OutputPortBase::init();
  }

  void OutputSendFileRequestPort ::
    addCallPort(InputSendFileRequestPort* callPort)
  {
    FW_ASSERT(callPort != nullptr);

    this->m_port = callPort;
    this->m_connObj = callPort;

#if FW_PORT_SERIALIZATION == 1
    this->m_serPort = nullptr;
#endif
  }

  Svc::SendFileResponse OutputSendFileRequestPort ::
    invoke(
        const SendFileRequestPortStrings::StringSize100& sourceFileName,
        const SendFileRequestPortStrings::StringSize100& destFileName,
        U32 offset,
        U32 length
    )
  {
#if FW_PORT_TRACING == 1
    this->trace();
#endif

    FW_ASSERT(this->m_port != nullptr);
    return this->m_port->invoke(sourceFileName, destFileName, offset, length);
  }

}
